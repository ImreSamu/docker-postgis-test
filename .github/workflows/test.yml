# testing : https://github.com/postgis/docker-postgis/pull/432
# original author: https://github.com/BowlesCR

name: TEST - Docker PostGIS CI
# Serialize publish-capable runs per ref so scheduled/push/manual runs queue instead of racing.
concurrency:
  group: publish-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

on:
  push:
  pull_request:
  workflow_dispatch:
  schedule:
    - cron: '15 13 * * *'

# ============================================================================
# FOR FORKING: Modify these settings in your forked repository
# ============================================================================
env:
  DOCKERHUB_REPO: imresamu/docker-postgis-test  # Change to your DockerHub repo
  GITHUB_REPO: ImreSamu/docker-postgis-test     # Change to your GitHub repo
  DOCKERHUB_SHORT_DESCRIPTION: "TEST REPO - PostGIS Docker"  # Short description for Docker Hub
  DOCKERHUB_README_PREFIX: "# ðŸš¨ **IGNORE: This is a TEST repository ONLY!** ðŸš¨ \n \n \n "  # Prefix to add to Docker Hub README (empty = no prefix)
  RUNNER_PLATFORMS_JSON: '["ubuntu-24.04","ubuntu-24.04-arm"]'  # Runner platforms used to expand the build matrix
#
# Also add these secrets in your repository settings:
#   https://github.com/${GITHUB_REPO}/settings/secrets/actions
#   - secrets.DOCKERHUB_USERNAME
#   - secrets.DOCKERHUB_ACCESS_TOKEN    ( READ, Write, Delete access )
# ============================================================================

defaults:
  run:
    shell: bash --noprofile --norc -euo pipefail {0}

jobs:

  setup:
    # This job sets up configuration constants and loads the CI matrix from matrix.yml.
    # - Constants: CANONICAL_REPO and SHOULD_PUBLISH flag (fork-friendly configuration)
    # - Matrix: BUILD_TARGETS and BUILD_INCLUDE arrays (automatically generated by ./update.sh)
    name: Setup and Load Configuration
    runs-on: ubuntu-latest
    outputs:
      CANONICAL_REPO: ${{ steps.constants.outputs.CANONICAL_REPO }}
      SHOULD_PUBLISH: ${{ steps.constants.outputs.SHOULD_PUBLISH }}
      BUILD_INCLUDE: ${{ steps.load-matrix.outputs.BUILD_INCLUDE }}
      BUILD_TARGETS: ${{ steps.load-matrix.outputs.BUILD_TARGETS }}
    steps:
      - name: Set constants
        id: constants
        env:
          VAR_CANONICAL: ${{ vars.CANONICAL_REPO }}
        run: |
          CANONICAL_REPO="${VAR_CANONICAL:-$GITHUB_REPO}"
          echo "CANONICAL_REPO=$CANONICAL_REPO" >> "$GITHUB_OUTPUT"

          # Compute if we should publish
          if [[ "${{ github.repository }}" == "$CANONICAL_REPO" ]] && \
             [[ "${{ github.ref }}" == "refs/heads/master" ]] && \
             [[ "${{ github.event_name }}" != "pull_request" ]]; then
            echo "SHOULD_PUBLISH=true" >> "$GITHUB_OUTPUT"
          else
            echo "SHOULD_PUBLISH=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Load matrix from matrix.yml
        id: load-matrix
        run: |
          echo "Using $(yq --version)"

          # Read build_targets from matrix.yml and convert to JSON
          BUILD_TARGETS=$(yq eval '.build_targets' matrix.yml -o=json -I=0)
          echo "BUILD_TARGETS=$BUILD_TARGETS" >> "$GITHUB_OUTPUT"

          # Expand build_targets Ã— runner platforms using RUNNER_PLATFORMS_JSON
          RUNNER_PLATFORMS=$(jq -c '.' <<< "$RUNNER_PLATFORMS_JSON")
          BUILD_INCLUDE=$(jq -c --argjson platforms "$RUNNER_PLATFORMS" '
            [ .[] as $combo | $platforms[] | $combo + {"runner-platform": .} ]
          ' <<< "$BUILD_TARGETS")
          echo "BUILD_INCLUDE=$BUILD_INCLUDE" >> "$GITHUB_OUTPUT"

          # Debug: Show what we loaded
          echo "Loaded BUILD_TARGETS with $(echo "$BUILD_TARGETS" | jq 'length') entries"
          echo "Expanded BUILD_INCLUDE with $(echo "$BUILD_INCLUDE" | jq 'length') entries"

      - name: Validate ./matrix.yml
        run: |
          echo "Validating ./matrix.yml..."

          # 1. Check build_targets exists and is not empty
          BUILD_COUNT=$(yq eval '.build_targets | length' matrix.yml)
          if [ "$BUILD_COUNT" -eq 0 ]; then
            echo "ERROR: matrix.yml has no build_targets"
            exit 1
          fi

          # 2. Check all entries have required non-empty fields: postgres, postgis, variant, tags
          INVALID_ENTRIES=$(yq eval '
            [.build_targets[] | select(
              .postgres == null or .postgres == "" or
              .postgis == null or .postgis == "" or
              .variant == null or .variant == "" or
              .tags == null or .tags == ""
            )]
          ' matrix.yml -o=json)

          if [ "$(echo "$INVALID_ENTRIES" | jq 'length')" -gt 0 ]; then
            echo "ERROR: Some entries have missing or empty required fields (postgres/postgis/variant/tags):"
            echo "$INVALID_ENTRIES" | jq '.'
            exit 1
          fi

          # 3. Verify exactly one entry has 'latest' tag
          LATEST_COUNT=$(yq eval '[.build_targets[] | select(.tags | contains("latest"))] | length' matrix.yml)
          if [ "$LATEST_COUNT" -ne 1 ]; then
            echo "ERROR: Expected exactly 1 entry with 'latest' tag, found: $LATEST_COUNT"
            yq eval '.build_targets[] | select(.tags | contains("latest"))' matrix.yml
            exit 1
          fi

          echo "matrix.yml valid: $BUILD_COUNT targets, all have required fields, 1 'latest' tag"

  make-docker-images:
    needs: setup
    strategy:
      matrix:
        include: ${{ fromJSON(needs.setup.outputs.BUILD_INCLUDE) }}

    name: "Build:${{ matrix.postgres }}-${{ matrix.postgis }}-${{ matrix.variant }} (${{ contains(matrix.runner-platform, 'arm') && 'arm64' || 'x86-64' }}) Docker image"
    runs-on: ${{ matrix.runner-platform }}
    continue-on-error: ${{ matrix.postgis == 'master' }}
    env:
      VERSION: ${{ matrix.postgres }}-${{ matrix.postgis }}
      VARIANT: ${{ matrix.variant }}
      # the "postgis/postgis" name is the expected test name; ( via ./test/postgis-config.sh )
      # changing it will break the official-images test script
      # this is only for CI test and not for Docker hub publishing
      CI_IMAGE_TAG: postgis/postgis:ci-${{ github.run_id }}-${{ matrix.postgres }}-${{ matrix.postgis }}-${{ matrix.variant }}-${{ contains(matrix.runner-platform, 'arm') && 'arm' || 'x64' }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v5

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image for ${{ env.VERSION }} ${{ env.VARIANT }}
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ${{ env.VERSION }}${{ env.VARIANT == 'alpine' && '/alpine' || ''}}
        file: ${{ env.VERSION }}${{ env.VARIANT == 'alpine' && '/alpine' || ''}}/Dockerfile
        tags: ${{ env.CI_IMAGE_TAG }}
        load: true
        push: false  # don't push until after testing

    - name: Check out official-images repo
      uses: actions/checkout@v5
      with:
        repository: docker-library/official-images
        path: official-images
        sparse-checkout: |
          test

    - name: Run official-images test script
      run: |
        ./official-images/test/run.sh -c ./official-images/test/config.sh -c test/postgis-config.sh "$CI_IMAGE_TAG" | tee test.log

    - name: Verify test results
      run: |
        if ! grep -q "'postgres-basics'.*passed" test.log || \
           ! grep -q "'postgres-initdb'.*passed" test.log || \
           ! grep -q "'postgis-basics'.*passed" test.log; then
          echo "ERROR: Required postgres/postgis tests did not pass!"
          exit 1
        fi
        echo "âœ“ All required tests passed"

    - name: Login to dockerhub
      id: login-dockerhub
      uses: docker/login-action@v3
      if: ${{ needs.setup.outputs.SHOULD_PUBLISH == 'true' }}
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Push image by digest
      id: push
      uses: docker/build-push-action@v5  # Build is cached, this is really just a push
      if: ${{ needs.setup.outputs.SHOULD_PUBLISH == 'true' && steps.login-dockerhub.outcome == 'success' }}
      with:
        context: ${{ env.VERSION }}${{ env.VARIANT == 'alpine' && '/alpine' || ''}}
        file: ${{ env.VERSION }}${{ env.VARIANT == 'alpine' && '/alpine' || ''}}/Dockerfile
        outputs: type=image,"name=${{ env.DOCKERHUB_REPO }}",push-by-digest=true,name-canonical=true,push=true

    - name: Export digest
      if: ${{ steps.push.outcome == 'success' }}
      run: |
        mkdir -p ${{ runner.temp }}/digests
        digest="${{ steps.push.outputs.digest }}"
        touch "${{ runner.temp }}/digests/${digest#sha256:}"

    - name: Upload digests
      if: ${{ steps.push.outcome == 'success' }}
      uses: actions/upload-artifact@v4
      with:
        name: digests-${{ env.VERSION }}-${{ env.VARIANT }}-${{ matrix.runner-platform }}
        path: ${{ runner.temp }}/digests/*
        if-no-files-found: error
        retention-days: 10

  merge-manifests:
    name: "Merge:${{ matrix.postgres }}-${{ matrix.postgis }}-${{ matrix.variant }} manifests and push to DockerHub"
    needs: [setup, make-docker-images]
    runs-on: ubuntu-24.04-arm  # Always on arm, because why not
    if: ${{ needs.setup.outputs.SHOULD_PUBLISH == 'true' }}
    # Ensure each tag variant is published by only one workflow run at a time to keep manifests consistent.
    concurrency:
      group: merge-${{ matrix.postgres }}-${{ matrix.postgis }}-${{ matrix.variant }}
      cancel-in-progress: false
    continue-on-error: ${{ matrix.postgis == 'master' }}
    env:
      VERSION: ${{ matrix.postgres }}-${{ matrix.postgis }}
      VARIANT: ${{ matrix.variant }}
    strategy:
      matrix:
        include: ${{ fromJSON(needs.setup.outputs.BUILD_TARGETS) }}

    steps:
    - name: Login to dockerhub
      id: login-dockerhub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Download digests
      uses: actions/download-artifact@v4
      with:
        path: ${{ runner.temp }}/digests
        pattern: digests-${{ env.VERSION }}-${{ env.VARIANT }}-*
        merge-multiple: true

    - name: Create manifest list and push
      working-directory: ${{ runner.temp }}/digests
      env:
        # Tags from matrix.yml (space-separated list generated by update.sh)
        MATRIX_TAGS: ${{ matrix.tags }}
      run: |
        # Build tag arguments from matrix.tags (generated by update.sh)
        # Each tag becomes: -t <repo>:<tag>
        TAG_ARGS=""
        for tag in $MATRIX_TAGS; do
          TAG_ARGS="$TAG_ARGS -t ${{ env.DOCKERHUB_REPO }}:${tag}"
        done

        echo "Creating multi-arch manifest with tags:$TAG_ARGS"

        # Create manifest from all architecture digests and push with all tags
        # shellcheck disable=SC2046,SC2086
        docker buildx imagetools create $TAG_ARGS \
          $(printf '${{ env.DOCKERHUB_REPO }}@sha256:%s ' *)

    - name: Inspect image  # Purely for debugging
      run: |
        sleep 5
        docker buildx imagetools inspect ${{ env.DOCKERHUB_REPO }}:${{ env.VERSION }}${{ env.VARIANT == 'alpine' && '-alpine' || ''}}

  dockerHubDescription:
    needs: [merge-manifests]
    runs-on: ubuntu-latest
    steps:
    - name: Checkout source
      uses: actions/checkout@v5

    - name: Prepare README with prefix
      run: |
        if [ -n "${{ env.DOCKERHUB_README_PREFIX }}" ]; then
          echo -e "${{ env.DOCKERHUB_README_PREFIX }}" > /tmp/dockerhub-readme.md
          cat README.md >> /tmp/dockerhub-readme.md
          mv /tmp/dockerhub-readme.md README.md
        fi

    - name: Update Docker Hub Description
      uses: peter-evans/dockerhub-description@v5
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}
        repository: ${{ env.DOCKERHUB_REPO }}
        short-description: "${{ env.DOCKERHUB_SHORT_DESCRIPTION }}"
        readme-filepath: ./README.md
