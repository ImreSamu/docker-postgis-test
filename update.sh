#!/bin/bash
# Derived from https://github.com/docker-library/postgres/blob/master/update.sh
set -Eeuo pipefail

log()  { echo "[INFO] $*"; }
warn() { echo "[WARN] $*" >&2; }
die()  { echo "[ERROR] $*" >&2; exit 1; }

repo_root="$(cd "$(dirname "$(readlink -f "$BASH_SOURCE")")" && pwd)"
cd "$repo_root"

autogenerated='NOTE: THIS DOCKERFILE IS GENERATED VIA "./update.sh"! PLEASE DO NOT EDIT IT DIRECTLY.'
dockerhublink="https://registry.hub.docker.com/r/postgis/postgis/tags?page=1&name="
githubrepolink="https://github.com/postgis/docker-postgis/blob/master"

# Matrix configuration for CI/CD
MATRIX_FILE="matrix.yml"
# The following version is considered to be the 'latest'.
LATEST_VERSION=17-3.5

defaultAlpinenSuite='3.22'
defaultDebianSuite='bullseye-slim'
declare -A debianSuite=(
    # https://github.com/docker-library/postgres/issues/582
    [11]='bullseye-slim'
    [12]='bullseye-slim'
    [13]='bullseye-slim'
    [14]='bullseye-slim'
    [15]='bullseye-slim'
    [16]='bullseye-slim'
    [17]='bullseye-slim'
    [18]='trixie-slim'
)

defaultPostgisDebPkgNameVersionSuffix='3'
declare -A postgisDebPkgNameVersionSuffixes=(
    [3.0]='3'
    [3.1]='3'
    [3.2]='3'
    [3.3]='3'
    [3.4]='3'
    [3.5]='3'
    [3.6]='3'
)

packagesBase='http://apt.postgresql.org/pub/repos/apt/dists/'

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

render_template() {
    local template="$1"
    local out="$2"
    shift 2

    local -a sed_args=()
    local kv key val
    for kv in "$@"; do
        key="${kv%%=*}"
        val="${kv#*=}"
        val="${val//\\/\\\\}"
        val="${val//&/\\&}"
        val="${val//|/\\|}"
        sed_args+=("-e" "s|${key}|${val}|g")
    done

    sed "${sed_args[@]}" "$template" > "$out"
}

detect_optimized_bucket() {
    local version_dir="$1"
    local variant="${2:-default}"

    if [[ "$version_dir" =~ alpha|beta|rc|master ]]; then
        echo "test"
    elif [[ "$variant" == "alpine" ]]; then
        echo "alpine"
    else
        echo "debian"
    fi
}

# Build Docker tag list for matrix.yml
build_tags() {
    local pg="$1"
    local postgis="$2"
    local variant="$3"
    local os_label="$4"
    local patch="$5"
    local combo="${pg}-${postgis}"
    local -a tags=()

    if [[ "$variant" == "alpine" ]]; then
        tags+=("${combo}-alpine")
        tags+=("${combo}-${os_label}")
    else
        tags+=("${combo}")
        tags+=("${combo}-${os_label}")
    fi

    if [[ "$patch" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        tags+=("${pg}-${patch}-${os_label}")
    fi

    if [[ "$combo" == "$LATEST_VERSION" && "$variant" == "default" ]]; then
        tags+=("latest")
    fi

    echo "${tags[*]}"
}

# Correct version sorting
version_reverse_sort() {
    sed -r "s/([0-9]+\.[0-9]+\.[0-9]+$)/\1\.9991/" | sort -Vr | sed s/\.9991$//
}

api_preference="github"
fetch_postgis_versions() {
    local REPO="postgis/postgis"
    local PER_PAGE=100
    local page=1
    postgis_all_v3_versions=""

    while true; do
        local response
        if [ "$api_preference" == "github" ]; then
            response=$(curl --silent "https://api.github.com/repos/$REPO/tags?per_page=$PER_PAGE&page=$page") || {
                warn "Failed to fetch postgis tags from api.github.com"
                return 1
            }
        else
            response=$(curl --silent "https://git.osgeo.org/gitea/api/v1/repos/${REPO}/tags?page=$page&limit=$PER_PAGE") || {
                warn "Failed to fetch postgis tags from git.osgeo.org"
                return 1
            }
        fi

        if echo "$response" | grep -q "API rate limit exceeded"; then
            die "API rate limit exceeded: $response"
        fi

        local tags count
        tags=$(echo "$response" | grep -Po '"name":\s*"\K[^"]+' || true)
        count=$(echo "$tags" | sed '/^$/d' | wc -l)
        if ((count == 0)); then
            break
        fi

        if ((page > 12)); then
            die "Too many pages (${page}) while fetching PostGIS tags"
        fi

        postgis_all_v3_versions+=" $tags"
        ((page++))
    done
}

# ---------------------------------------------------------------------------
# Version resolution and recording
# ---------------------------------------------------------------------------

# Outputs (globals):
#   postgisMajMin, postgisPackageName, postgisFullVersion, postgisMajor, postgisDocSrc
resolve_debian_postgis_version() {
    local postgres_main="$1"
    local postgis_version="$2"
    local version_list="$3"

    postgisPackageName=""
    postgisFullVersion=""
    postgisMajor=""
    postgisDocSrc=""
    postgisMajMin=""

    if [[ "$postgis_version" == "master" ]]; then
        postgisFullVersion="$postgis_version"
        postgisDocSrc="development: postgis, geos, proj, gdal"
        return 0
    fi

    postgisMajMin="$( echo "${postgis_version}" | cut -d. -f1 ).$( echo "${postgis_version}" | cut -d. -f2 )"
    log "postgisMajMin=${postgisMajMin}"

    postgisPackageName="postgresql-${postgres_main}-postgis-${postgisDebPkgNameVersionSuffixes[${postgisMajMin}]}"
    postgisFullVersion="$(echo "$version_list" | awk -F ': ' '$1 == "Package" { pkg = $2 } $1 == "Version" && pkg == "'"$postgisPackageName"'" { print $2; exit }' || true)"
    log "postgisPackageName=${postgisPackageName}"
    log "postgisFullVersion=${postgisFullVersion}"

    local debianPostgisMajMin
    debianPostgisMajMin="$( echo "${postgisFullVersion}" | cut -d. -f1 ).$( echo "${postgisFullVersion}" | cut -d. -f2 )"
    if [[ "$debianPostgisMajMin" == "$postgisMajMin" ]]; then
        log "debian postgis version matches"
        postgisMajor="${postgisDebPkgNameVersionSuffixes[${postgisMajMin}]}"
        postgisDocSrc="${postgisFullVersion%%+*}"
    else
        warn "debian postgis version mismatch or not available"
        postgisFullVersion=""
        postgisMajor=""
        postgisDocSrc=""
    fi
}

# Outputs (globals):
#   srcVersion, srcSha256, postgisDocSrc (updated for Alpine docs/tags)
resolve_alpine_postgis_version() {
    local version_dir="$1"
    local postgis_version="$2"

    srcVersion=""
    srcSha256=""

    if [[ "$postgis_version" == "master" ]]; then
        return 0
    fi

    if [[ -d "$version_dir/alpine" ]]; then
        local major minor
        major="$(echo "$postgisMajMin" | cut -d. -f1)"
        minor="$(echo "$postgisMajMin" | cut -d. -f2)"

        srcVersion="$(echo "$postgis_all_v3_versions_array_string" | tr ' ' '\n' | grep "^${major}\.${minor}\." | grep -v '[a-zA-Z]' | head -n 1 || true)"

        if [[ -z "$srcVersion" ]]; then
            log "No stable release found for ${major}.${minor}; falling back"
            if [[ "$postgis_version" =~ alpha|beta|rc ]]; then
                srcVersion="$postgis_version"
            else
                srcVersion="${postgisFullVersion%%+*}"
            fi
        fi

        srcSha256="$(curl -sSL "https://github.com/postgis/postgis/archive/$srcVersion.tar.gz" | sha256sum | awk '{ print $1 }')"
        log "Selected PostGIS version for Alpine: ${srcVersion}"
        postgisDocSrc="$srcVersion"
    else
        srcVersion="${postgisFullVersion%%+*}"
        srcSha256="$(curl -sSL "https://github.com/postgis/postgis/archive/$srcVersion.tar.gz" | sha256sum | awk '{ print $1 }')"
        postgisDocSrc="$srcVersion"
    fi
}

record_target() {
    local version_dir="$1"
    local postgres_display="$2"
    local postgres_main="$3"
    local postgis_version="$4"
    local variant="$5"      # default|alpine
    local os_doc="$6"       # e.g. debian:bullseye
    local os_label="$7"     # e.g. bullseye or alpine3.22
    local doc_src="$8"      # PostGIS column + patch for tag gen

    local bucket image_tag dockerfile_path
    if [[ "$variant" == "alpine" ]]; then
        bucket="$(detect_optimized_bucket "$version_dir" "alpine")"
        image_tag="${version_dir}-alpine"
        dockerfile_path="${version_dir}/alpine/Dockerfile"
    else
        bucket="$(detect_optimized_bucket "$version_dir" "default")"
        image_tag="${version_dir}"
        dockerfile_path="${version_dir}/Dockerfile"
        variant="default"
    fi

    echo "| [postgis/postgis:${image_tag}](${dockerhublink}${image_tag}) | [Dockerfile](${githubrepolink}/${dockerfile_path}) | ${os_doc} | ${postgres_display} | ${doc_src} |" >> "_dockerlists_${bucket}.md"

    local tags
    tags="$(build_tags "${postgres_main}" "${postgis_version}" "${variant}" "${os_label}" "${doc_src}")"
    log "tags: ${tags}"
    echo "  - { postgres: '${postgres_main}', postgis: '${postgis_version}', variant: '${variant}', tags: '${tags}' }" >> "_matrixlist_${bucket}.yml"
}

# ---------------------------------------------------------------------------
# Generation phases
# ---------------------------------------------------------------------------

init_outputs() {
    for optimized in debian alpine test; do
        rm -f "_dockerlists_${optimized}.md"
        {
            echo "<!-- This part is automatically generated by ./update.sh. Do not modify this section manually. -->"
            echo "| DockerHub image | Dockerfile | OS | Postgres | PostGIS |"
            echo "| --------------- | ---------- | -- | -------- | ------- |"
        } > "_dockerlists_${optimized}.md"

        rm -f "_matrixlist_${optimized}.yml"
        {
            echo "# This file is automatically generated by ./update.sh"
            echo "# Category: ${optimized}"
            echo "# Entries that successfully generated Dockerfiles"
            echo ""
        } > "_matrixlist_${optimized}.yml"
    done
}

fetch_remote_state() {
    cgalGitHash="$(git ls-remote https://github.com/CGAL/cgal.git heads/main | awk '{ print $1}')"
    sfcgalGitHash="$(git ls-remote https://gitlab.com/SFCGAL/SFCGAL.git heads/master | awk '{ print $1}')"
    projGitHash="$(git ls-remote https://github.com/OSGeo/PROJ.git heads/master | awk '{ print $1}')"
    gdalGitHash="$(git ls-remote https://github.com/OSGeo/gdal.git refs/heads/master | grep '\srefs/heads/master' | awk '{ print $1}')"
    geosGitHash="$(git ls-remote https://github.com/libgeos/geos.git heads/main | awk '{ print $1}')"
    postgisGitHash="$(git ls-remote https://github.com/postgis/postgis.git heads/master | awk '{ print $1}')"

    fetch_postgis_versions || die "Error fetching PostGIS versions"
    postgis_all_v3_versions="$(echo "$postgis_all_v3_versions" | sed '/^$/d' | grep '^3\.' | version_reverse_sort)"
    postgis_all_v3_versions_array_string="$(echo "$postgis_all_v3_versions" | tr '\n' ' ')"
    log "postgis_all_v3_versions_array_string = ${postgis_all_v3_versions_array_string}"
}

declare -a matrix_skip_comments=()
declare -A suitePackageList=() suiteArches=()

generate_debian() {
    local version_dir="$1"
    local postgresVersion="$2"
    local postgres_main="$3"
    local postgis_version="$4"
    local suite="$5"
    local boostVersion="$6"

    if [[ -z "$postgisFullVersion" ]]; then
        log "SKIP debian version"
        echo " # placeholder Dockerfile"                                          > "$version_dir/Dockerfile"
        echo " # Debian version of postgis $postgisFullVersion is not detected!" >> "$version_dir/Dockerfile"
        echo " # This is an autogenerated message of ./update.sh "               >> "$version_dir/Dockerfile"
        rm -f "$version_dir/"*.sh "$version_dir/"*.md
        matrix_skip_comments+=("postgres: ${postgres_main}, postgis: ${postgis_version}, variant: default - Reason: placeholder (Debian ${suite} package not available)")

        local _postgisMinor
        _postgisMinor="$(echo "$postgisMajMin" | cut -d. -f2)"
        postgisFullVersion="$(echo "$postgis_all_v3_versions" | grep "^3\.${_postgisMinor}\." | grep -v '[a-zA-Z]' | version_reverse_sort | head -n 1 || true)"
        if [[ -z "${postgisFullVersion}" ]]; then
            postgisFullVersion="$(echo "$postgis_all_v3_versions" | grep "^3\.${_postgisMinor}\." | version_reverse_sort | head -n 1 || true)"
        fi
        postgisDocSrc="$postgisFullVersion"
        log "postgisFullVersion (fallback for alpine) = ${postgisFullVersion}"
        return 0
    fi

    cp -p initdb-postgis.sh update-postgis.sh "$version_dir/"

    local template
    if [[ "$postgis_version" == "master" ]]; then
        template="Dockerfile.master.template"
    else
        template="Dockerfile.template"
    fi

    render_template "$template" "$version_dir/Dockerfile" \
        "%%TXT_AUTOGENERATED%%=$autogenerated" \
        "%%PG_MAJOR%%=$postgresVersion" \
        "%%POSTGIS_MAJOR%%=$postgisMajor" \
        "%%POSTGIS_VERSION%%=$postgisFullVersion" \
        "%%POSTGIS_GIT_HASH%%=$postgisGitHash" \
        "%%CGAL_GIT_HASH%%=$cgalGitHash" \
        "%%SFCGAL_GIT_HASH%%=$sfcgalGitHash" \
        "%%PROJ_GIT_HASH%%=$projGitHash" \
        "%%GDAL_GIT_HASH%%=$gdalGitHash" \
        "%%GEOS_GIT_HASH%%=$geosGitHash" \
        "%%BOOST_VERSION%%=$boostVersion" \
        "%%DEBIAN_VERSION%%=$suite"

    record_target "$version_dir" "$postgresVersion" "$postgres_main" "$postgis_version" "default" "debian:${suite}" "${suite}" "$postgisDocSrc"
}

generate_alpine() {
    local version_dir="$1"
    local postgresVersion="$2"
    local postgres_main="$3"
    local postgis_version="$4"

    local variant="alpine"
    if [[ ! -d "$version_dir/$variant" ]]; then
        return 0
    fi

    cp -p initdb-postgis.sh update-postgis.sh "$version_dir/$variant/"

    render_template "Dockerfile.alpine.template" "$version_dir/$variant/Dockerfile" \
        "%%TXT_AUTOGENERATED%%=$autogenerated" \
        "%%PG_MAJOR%%=$postgresVersion" \
        "%%POSTGIS_VERSION%%=$srcVersion" \
        "%%POSTGIS_SHA256%%=$srcSha256"

    record_target "$version_dir" "$postgresVersion" "$postgres_main" "$postgis_version" "alpine" "alpine:${defaultAlpinenSuite}" "alpine${defaultAlpinenSuite}" "$postgisDocSrc"
}

process_version() {
    local version_dir="$1"
    local postgresVersion postgisVersion
    IFS=- read postgresVersion postgisVersion <<< "$version_dir"

    log "---- generate Dockerfile for ${version_dir} ----"
    log "postgresVersion=${postgresVersion}"
    log "postgisVersion=${postgisVersion}"

    local tag suite
    if [[ "$postgisVersion" == "2.5" ]]; then
        tag='stretch-slim'
    else
        tag="${debianSuite[$postgresVersion]:-$defaultDebianSuite}"
    fi
    suite="${tag%%-slim}"

    if [ -z "${suitePackageList["$suite"]:+isset}" ]; then
        suitePackageList["$suite"]="$(curl -fsSL "${packagesBase}/${suite}-pgdg/main/binary-amd64/Packages.bz2" | bunzip2)"
    fi
    if [ -z "${suiteArches["$suite"]:+isset}" ]; then
        suiteArches["$suite"]="$(curl -fsSL "${packagesBase}/${suite}-pgdg/Release" | awk -F ':[[:space:]]+' '$1 == "Architectures" { gsub(/[[:space:]]+/, "|", $2); print $2 }')"
    fi

    local postgresVersionMain versionList fullVersion
    postgresVersionMain="$(echo "$postgresVersion" | awk -F 'alpha|beta|rc' '{print $1}')"
    versionList="$(echo "${suitePackageList["$suite"]}"; curl -fsSL "${packagesBase}/${suite}-pgdg/${postgresVersionMain}/binary-amd64/Packages.bz2" | bunzip2)"
    fullVersion="$(echo "$versionList" | awk -F ': ' '$1 == "Package" { pkg = $2 } $1 == "Version" && pkg == "postgresql-'"$postgresVersionMain"'" { print $2; exit }' || true)"

    local boostVersion
    case "$suite" in
        bullseye) boostVersion="1.74.0" ;;
        trixie)   boostVersion="1.88.0" ;;
        *) die "Unknown debian suite: ${suite}" ;;
    esac

    resolve_debian_postgis_version "$postgresVersionMain" "$postgisVersion" "$versionList"
    generate_debian "$version_dir" "$postgresVersion" "$postgresVersionMain" "$postgisVersion" "$suite" "$boostVersion"

    resolve_alpine_postgis_version "$version_dir" "$postgisVersion"
    generate_alpine "$version_dir" "$postgresVersion" "$postgresVersionMain" "$postgisVersion"
}

apply_readme() {
    bash ./apply-readme.sh
}

generate_matrix_yml() {
    local output_file="$1"
    local temp_file="${output_file}.tmp"

    cat > "$temp_file" << EOF
# =============================================================================
# WARNING: AUTOMATICALLY GENERATED by ./update.sh - DO NOT EDIT MANUALLY!
# Used by: .github/workflows/*.yml
# =============================================================================
# - build_targets: All buildable postgres-postgis-variant combinations
# =============================================================================

EOF

    if [ ${#matrix_skip_comments[@]} -gt 0 ]; then
        echo "# --- Placeholder/skipped combinations (NOT included in build target list) ---" >> "$temp_file"
        for comment in "${matrix_skip_comments[@]}"; do
            echo "# - ${comment}" >> "$temp_file"
        done
        echo "" >> "$temp_file"
    fi

    echo "build_targets:" >> "$temp_file"

    local has_entries=false
    for optimized in debian alpine test; do
        if [ -f "_matrixlist_${optimized}.yml" ]; then
            grep "^  -" "_matrixlist_${optimized}.yml" >> "$temp_file" 2>/dev/null && has_entries=true
        fi
    done

    if [ "$has_entries" = false ]; then
        echo "  []" >> "$temp_file"
    fi

    echo "" >> "$temp_file"
    echo "" >> "$temp_file"
    echo "# ==============================================================================" >> "$temp_file"

    local target_count
    target_count=$(grep -c "^  - { postgres:" "$temp_file" || echo "0")
    echo "# Summary: ${target_count} combinations" >> "$temp_file"
    echo "# ==============================================================================" >> "$temp_file"
    echo "# End of matrix.yml" >> "$temp_file"

    if [ -f "$output_file" ] && cmp -s "$temp_file" "$output_file"; then
        log "matrix.yml unchanged"
        rm "$temp_file"
    else
        mv "$temp_file" "$output_file"
        log "matrix.yml generated/updated"
    fi
}

generate_matrix() {
    log "Generating matrix.yml from _matrixlist_*.yml files"
    generate_matrix_yml "$MATRIX_FILE"
}

main() {
    local versions=( "$@" )
    if [ ${#versions[@]} -eq 0 ]; then
        versions=( */Dockerfile )
    fi
    versions=( "${versions[@]%/Dockerfile}" )

    IFS=$'\n'; versions=( $(echo "${versions[*]}" | sort -V) ); unset IFS

    init_outputs
    fetch_remote_state

    for version_dir in "${versions[@]}"; do
        process_version "$version_dir"
    done

    log "|-------------------------|"
    log "|-   Generated images    -|"
    log "|-------------------------|"
    for optimized in debian alpine test; do
        log "---- ${optimized} ----"
        cat "_dockerlists_${optimized}.md"
        echo " "
    done

    apply_readme
    generate_matrix

    log "update done && git status:"
    git status
}

main "$@"
