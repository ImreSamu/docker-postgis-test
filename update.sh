#!/bin/bash
# Derived from https://github.com/docker-library/postgres/blob/master/update.sh
set -Eeuo pipefail

cd "$(dirname "$(readlink -f "$BASH_SOURCE")")"

versions=( "$@" )
if [ ${#versions[@]} -eq 0 ]; then
	versions=( */Dockerfile )
fi
versions=( "${versions[@]%/Dockerfile}" )

for optimized in debian alpine test; do
    rm -f      _dockerlists_${optimized}.md
    echo "<!-- This part is automatically generated by ./update.sh. Do not modify this section manually. -->" > _dockerlists_${optimized}.md
    echo "| DockerHub image | Dockerfile | OS | Postgres | PostGIS |" >> _dockerlists_${optimized}.md
    echo "| --------------- | ---------- | -- | -------- | ------- |" >> _dockerlists_${optimized}.md

    # Matrix working file initialization (parallel to _dockerlists_*.md)
    rm -f      _matrixlist_${optimized}.yml
    echo "# This file is automatically generated by ./update.sh" > _matrixlist_${optimized}.yml
    echo "# Category: ${optimized}" >> _matrixlist_${optimized}.yml
    echo "# Entries that successfully generated Dockerfiles" >> _matrixlist_${optimized}.yml
    echo "" >> _matrixlist_${optimized}.yml
done

autogenerated='NOTE: THIS DOCKERFILE IS GENERATED VIA "make update"! PLEASE DO NOT EDIT IT DIRECTLY.'

dockerhublink="https://registry.hub.docker.com/r/postgis/postgis/tags?page=1&name="
githubrepolink="https://github.com/postgis/docker-postgis/blob/master"

# Matrix configuration for CI/CD
MATRIX_FILE="matrix.yml"
MATRIX_RUNNER_PLATFORMS=('ubuntu-24.04' 'ubuntu-24.04-arm')

# sort version numbers with highest last (so it goes first in .travis.yml)
IFS=$'\n'; versions=( $(echo "${versions[*]}" | sort -V) ); unset IFS

defaultAlpinenSuite='3.22'
defaultDebianSuite='bullseye-slim'
declare -A debianSuite=(
    # https://github.com/docker-library/postgres/issues/582
    [11]='bullseye-slim'
    [12]='bullseye-slim'
    [13]='bullseye-slim'
    [14]='bullseye-slim'
    [15]='bullseye-slim'
    [16]='bullseye-slim'
    [17]='bullseye-slim'
    [18]='trixie-slim'
)

defaultPostgisDebPkgNameVersionSuffix='3'
declare -A postgisDebPkgNameVersionSuffixes=(
    [3.0]='3'
    [3.1]='3'
    [3.2]='3'
    [3.3]='3'
    [3.4]='3'
    [3.5]='3'
    [3.6]='3'
)

packagesBase='http://apt.postgresql.org/pub/repos/apt/dists/'

cgalGitHash="$(git ls-remote https://github.com/CGAL/cgal.git heads/master | awk '{ print $1}')"
sfcgalGitHash="$(git ls-remote https://gitlab.com/SFCGAL/SFCGAL.git heads/master | awk '{ print $1}')"
projGitHash="$(git ls-remote https://github.com/OSGeo/PROJ.git heads/master | awk '{ print $1}')"
gdalGitHash="$(git ls-remote https://github.com/OSGeo/gdal.git refs/heads/master | grep '\srefs/heads/master' | awk '{ print $1}')"
geosGitHash="$(git ls-remote https://github.com/libgeos/geos.git heads/main | awk '{ print $1}')"
postgisGitHash="$(git ls-remote https://github.com/postgis/postgis.git heads/master | awk '{ print $1}')"

#-------------------------------------------
# Correct version sorting
function version_reverse_sort() {
    # This function sorts version numbers in reverse order,
    # ensuring that versions without pre-release tags (e.g., "3.4.0")
    # are ranked higher than those with pre-release tags (e.g., "3.4.0rc4").
    # It adds a ".9991" suffix to versions without pre-release tags,
    # sorts them with `sort -Vr`, and then removes the ".9991" suffix.
    sed -r "s/([0-9]+\.[0-9]+\.[0-9]+$)/\1\.9991/" | sort -Vr | sed s/\.9991$//
}

api_preference="github"
function fetch_postgis_versions() {
    # get all postgis versions from github
    local REPO="postgis/postgis"
    local PER_PAGE=100 # You can ask for up to 100 results per page
    local page=1
    postgis_all_v3_versions=""

    while true; do
        local response
        if [ "$api_preference" == "github" ]; then
            response=$(curl --silent "https://api.github.com/repos/$REPO/tags?per_page=$PER_PAGE&page=$page") || {
                echo "Failed to fetch postgis_versions from api.github.com/repos/$REPO/tags"
                return 1
            }
        elif [ "$api_preference" == "osgeo" ]; then
            response=$(curl --silent "https://git.osgeo.org/gitea/api/v1/repos/${REPO}/tags?page=$page&limit=$PER_PAGE") || {
                echo "Failed to fetch postgis_versions from git.osgeo.org/gitea/api/v1/repos/${REPO}/tags"
                return 1
            }
        fi

        # Check for rate limit exceeded error - related to api.github.com
        if echo "$response" | grep -q "API rate limit exceeded"; then
            echo "Error: API rate limit exceeded!"
            echo "$response"
            exit 1
        fi

        # Extract tag names from the JSON response
        local tags
        tags=$(echo "$response" | grep -Po '"name":\s*"\K[^"]+' || true)
        local count
        count=$(echo "$tags" | sed '/^$/d' | wc -l)

        if ((count == 0)); then
            break
        fi

        if ((page > 12)); then
            echo "Too many pages: ${page} - exiting; unexpected and something is wrong!"
            exit 1
        fi

        postgis_all_v3_versions+=" $tags"

        ((page++))
    done
}

fetch_postgis_versions || {
    echo "Error fetching postgis versions! Maybe network or server error!"
    exit 1
}

# Keep 3.* versions only
postgis_all_v3_versions=$(echo "$postgis_all_v3_versions" | sed '/^$/d' | grep '^3\.' | version_reverse_sort)
postgis_all_v3_versions_array_string=$(echo "$postgis_all_v3_versions" | tr '\n' ' ')
echo "postgis_all_v3_versions_array_string = ${postgis_all_v3_versions_array_string}"
echo " "

#-------------------------------------------

# Matrix data collection for skipped versions (comments only)
declare -a matrix_skip_comments=()
# The _matrixlist_*.yml files are written directly in the loop

declare -A suitePackageList=() suiteArches=()
for version in "${versions[@]}"; do
    IFS=- read postgresVersion postgisVersion <<< "$version"

    echo " "
    echo "---- generate Dockerfile for $version ----"
    echo "postgresVersion=$postgresVersion"
    echo "postgisVersion=$postgisVersion"

    if [ "2.5" == "$postgisVersion" ]; then
        # posgis 2.5 only in the stretch ; no bullseye version
        tag='stretch-slim'
    else
        tag="${debianSuite[$postgresVersion]:-$defaultDebianSuite}"
    fi
    suite="${tag%%-slim}"

    if [ -z "${suitePackageList["$suite"]:+isset}" ]; then
        suitePackageList["$suite"]="$(curl -fsSL "${packagesBase}/${suite}-pgdg/main/binary-amd64/Packages.bz2" | bunzip2)"
    fi
    if [ -z "${suiteArches["$suite"]:+isset}" ]; then
        suiteArches["$suite"]="$(curl -fsSL "${packagesBase}/${suite}-pgdg/Release" | awk -F ':[[:space:]]+' '$1 == "Architectures" { gsub(/[[:space:]]+/, "|", $2); print $2 }')"
    fi

    postgresVersionMain="$(echo "$postgresVersion" | awk -F 'alpha|beta|rc' '{print $1}')"
    versionList="$(echo "${suitePackageList["$suite"]}"; curl -fsSL "${packagesBase}/${suite}-pgdg/${postgresVersionMain}/binary-amd64/Packages.bz2" | bunzip2)"
    fullVersion="$(echo "$versionList" | awk -F ': ' '$1 == "Package" { pkg = $2 } $1 == "Version" && pkg == "postgresql-'"$postgresVersionMain"'" { print $2; exit }' || true)"

    if [ "$suite" = "bullseye" ]; then
        boostVersion="1.74.0"
    elif [ "$suite" = "trixie" ]; then
        boostVersion="1.88.0"
    else
        echo "Unknown debian version; stop"
        exit 1
    fi


    optimized=""
    if [[ "$version" =~ "alpha" || "$version" =~ "beta" || "$version" =~ "rc" || "$version" =~ "master" ]];
    then
        optimized="test"
    else
        optimized="debian"
    fi
    echo "optimized=$optimized"

    debianPostgisMajMin=""
    if [ "master" == "$postgisVersion" ]; then
        postgisPackageName=""
        postgisFullVersion="$postgisVersion"
        postgisMajor=""
        postgisDocSrc="development: postgis, geos, proj, gdal"
    else
        postgisMajMin="$( echo "${postgisVersion}" | cut -d. -f1 ).$( echo "${postgisVersion}" | cut -d. -f2 )"
        echo "postgisMajMin=${postgisMajMin}"

        postgisPackageName="postgresql-${postgresVersionMain}-postgis-${postgisDebPkgNameVersionSuffixes[${postgisMajMin}]}"
        postgisFullVersion="$(echo "$versionList" | awk -F ': ' '$1 == "Package" { pkg = $2 } $1 == "Version" && pkg == "'"$postgisPackageName"'" { print $2; exit }' || true)"
        echo "postgisPackageName=${postgisPackageName}"
        echo "postgisFullVersion=${postgisFullVersion}"

        debianPostgisMajMin="$( echo "${postgisFullVersion}" | cut -d. -f1 ).$( echo "${postgisFullVersion}" | cut -d. -f2 )"

        if [ "$debianPostgisMajMin" == "$postgisMajMin" ]; then
            echo "debian postgis version is OK "
            postgisMajor="${postgisDebPkgNameVersionSuffixes[${postgisMajMin}]}"
            postgisDocSrc="${postgisFullVersion%%+*}"
        else
            echo "debian postgis is not updated, different .. "
            postgisFullVersion=""
            postgisMajor=""
            postgisDocSrc=""
        fi
    fi

    if [ -z "$postgisFullVersion" ]
    then
        echo "SKIP debian version";
        # debain version not found;
        echo " # placeholder Dockerfile"                                         > "$version/Dockerfile"
        echo " # Debian version of postgis $postgisFullVersion is not detected!">> "$version/Dockerfile"
        echo " # This is an autogenerated message of ./update.sh "              >> "$version/Dockerfile"
        rm -f "$version/*.sh"
        rm -f "$version/*.md"
        # Matrix skip info: This does NOT go into _dockerlists_*.md, so NOT in matrix either
        matrix_skip_comments+=("postgres: ${postgresVersionMain}, postgis: ${postgisVersion}, variant: default - Reason: placeholder (Debian ${suite} package not available)")
        # detect the exact Postgis version - for the alpine version
        # check the latest released 3.x version (so not alpha/beta/rc)
        _postgisMinor=$(echo "$postgisMajMin" | cut -d. -f2)
        postgisFullVersion=$(echo "$postgis_all_v3_versions" | grep "^3\.${_postgisMinor}\." | grep -v '[a-zA-Z]' | version_reverse_sort | head -n 1 || true)
        # Check if the result is empty
        if [[ -z "${postgisFullVersion}" ]]; then
            # If empty, run the command again without excluding pre-releases (alpha/beta/rc)
            postgisFullVersion=$(echo "$postgis_all_v3_versions" | grep "^3\.${_postgisMinor}\." | version_reverse_sort | head -n 1 || true)
        fi
        postgisDocSrc=$postgisFullVersion
        echo "!!!!! postgisFullVersion = ${postgisFullVersion}";
    else
        (
            set -x
            cp -p initdb-postgis.sh update-postgis.sh "$version/"
            if [ "master" == "$postgisVersion" ]; then
              cat Dockerfile.master.template > "$version/Dockerfile"
            else
              cat Dockerfile.template        > "$version/Dockerfile"
            fi
            sed -i 's/%%TXT_AUTOGENERATED%%/'"$autogenerated"'/g; s/%%PG_MAJOR%%/'$postgresVersion'/g; s/%%POSTGIS_MAJOR%%/'$postgisMajor'/g; s/%%POSTGIS_VERSION%%/'$postgisFullVersion'/g; s/%%POSTGIS_GIT_HASH%%/'$postgisGitHash'/g; s/%%CGAL_GIT_HASH%%/'$cgalGitHash'/g; s/%%SFCGAL_GIT_HASH%%/'$sfcgalGitHash'/g; s/%%PROJ_GIT_HASH%%/'$projGitHash'/g; s/%%GDAL_GIT_HASH%%/'$gdalGitHash'/g; s/%%GEOS_GIT_HASH%%/'$geosGitHash'/g; s/%%BOOST_VERSION%%/'"$boostVersion"'/g; s/%%DEBIAN_VERSION%%/'"$suite"'/g;' "$version/Dockerfile"

            # ===== CRITICAL POINT: Documentation + Matrix entry (parallel writing) =====
            # This line writes to _dockerlists_*.md:
            echo "| [postgis/postgis:${version}](${dockerhublink}${version}) | [Dockerfile](${githubrepolink}/${version}/Dockerfile) | debian:${suite} | ${postgresVersion} | ${postgisDocSrc} |" >> _dockerlists_${optimized}.md
            # Matrix entry IMMEDIATELY after _dockerlists_*.md write
            # If it goes into _dockerlists_*.md → it goes into _matrixlist_*.yml too!
            echo "  - { postgres: '${postgresVersionMain}', postgis: '${postgisVersion}', variant: 'default' }" >> _matrixlist_${optimized}.yml
            # ===== END CRITICAL POINT =====
        )
    fi

    if [ "master" == "$postgisVersion" ]; then
        srcVersion=""
        srcSha256=""
    elif [ -d "$version/alpine" ]; then
        # For Alpine, get the latest release in the same minor version series
        _postgisMajor=$(echo "$postgisMajMin" | cut -d. -f1)
        _postgisMinor=$(echo "$postgisMajMin" | cut -d. -f2)

        # Find the latest non-preview release for this minor version
        srcVersion=$(echo "$postgis_all_v3_versions_array_string" | tr ' ' '\n' | grep "^${_postgisMajor}\.${_postgisMinor}\." | grep -v '[a-zA-Z]' | head -n 1 || true)

        # If no stable release found, fall back to the debian version
        if [ -z "$srcVersion" ]; then
            echo " No stable release found for ${_postgisMajor}.${_postgisMinor}. Falling back ..."
            # For alpha/beta/rc versions, use the version from directory name
            if [[ "$postgisVersion" =~ alpha|beta|rc ]]; then
                srcVersion="$postgisVersion"
            else
                srcVersion="${postgisFullVersion%%+*}"
            fi
        fi

        srcSha256="$(curl -sSL "https://github.com/postgis/postgis/archive/$srcVersion.tar.gz" | sha256sum | awk '{ print $1 }')"
        echo "Selected PostGIS version for Alpine: ${srcVersion}"
        postgisDocSrc=$srcVersion
    else
        srcVersion="${postgisFullVersion%%+*}"
        srcSha256="$(curl -sSL "https://github.com/postgis/postgis/archive/$srcVersion.tar.gz" | sha256sum | awk '{ print $1 }')"
        postgisDocSrc=$srcVersion
    fi

    for variant in alpine; do
        if [ ! -d "$version/$variant" ]; then
            continue
        fi
        (
            set -x
            if [ "$optimized" != "test" ]; then
              optimized="alpine"
            fi
            cp -p Dockerfile.alpine.template initdb-postgis.sh update-postgis.sh "$version/$variant/"
            mv "$version/$variant/Dockerfile.alpine.template" "$version/$variant/Dockerfile"
            sed -i 's/%%TXT_AUTOGENERATED%%/'"$autogenerated"'/g; s/%%PG_MAJOR%%/'"$postgresVersion"'/g; s/%%POSTGIS_VERSION%%/'"$srcVersion"'/g; s/%%POSTGIS_SHA256%%/'"$srcSha256"'/g' "$version/$variant/Dockerfile"

            # ===== CRITICAL POINT: Documentation + Matrix entry (parallel writing) =====
            # This line writes to _dockerlists_*.md:
            echo "| [postgis/postgis:${version}-${variant}](${dockerhublink}${version}-${variant}) | [Dockerfile](${githubrepolink}/${version}/${variant}/Dockerfile) | alpine:${defaultAlpinenSuite} | ${postgresVersion} | ${postgisDocSrc} |" >> _dockerlists_${optimized}.md
            # Matrix entry IMMEDIATELY after _dockerlists_*.md write
            # If it goes into _dockerlists_*.md → it goes into _matrixlist_*.yml too!
            echo "  - { postgres: '${postgresVersionMain}', postgis: '${postgisVersion}', variant: 'alpine' }" >> _matrixlist_${optimized}.yml
            # ===== END CRITICAL POINT =====
        )
    done
done

echo "|-------------------------|"
echo "|-   Generated images    -|"
echo "|-------------------------|"

for optimized in debian alpine test; do
    echo " "
    echo "---- ${optimized} ----"
    cat _dockerlists_${optimized}.md
done

# update README.md
bash ./apply-readme.sh

# Generate matrix.yml from _matrixlist_*.yml files
function generate_matrix_yml() {
    local output_file="$1"
    local temp_file="${output_file}.tmp"

    # Generate platform list string from MATRIX_RUNNER_PLATFORMS
    local platforms_str=$(printf '%s, ' "${MATRIX_RUNNER_PLATFORMS[@]}")
    platforms_str=${platforms_str%, }  # Remove trailing comma+space

    # --- Header ---
    cat > "$temp_file" << EOF
# =============================================================================
# WARNING: AUTOMATICALLY GENERATED by ./update.sh - DO NOT EDIT MANUALLY!
# Used by: .github/workflows/*.yml
# =============================================================================
# - merge_include: All buildable postgres-postgis-variant combinations
# - build_include: merge_include × runner platforms (${platforms_str})
# =============================================================================

EOF

    # --- Skip comments ---
    if [ ${#matrix_skip_comments[@]} -gt 0 ]; then
        echo "# --- Placeholder/skipped combinations (NOT included in build/merge lists) ---" >> "$temp_file"
        for comment in "${matrix_skip_comments[@]}"; do
            echo "# - ${comment}" >> "$temp_file"
        done
        echo "" >> "$temp_file"
    fi

    # --- merge_include ---
    echo "merge_include:" >> "$temp_file"

    # Merge from _matrixlist_*.yml files
    local has_entries=false
    for optimized in debian alpine test; do
        if [ -f "_matrixlist_${optimized}.yml" ]; then
            # Skip header lines (# and empty), only take entry lines
            grep "^  -" "_matrixlist_${optimized}.yml" >> "$temp_file" 2>/dev/null && has_entries=true
        fi
    done

    if [ "$has_entries" = false ]; then
        echo "  []" >> "$temp_file"
    fi

    echo "" >> "$temp_file"

    # --- build_include ---
    echo "build_include:" >> "$temp_file"

    # Expand every merge entry with every platform
    if [ "$has_entries" = false ]; then
        echo "  []" >> "$temp_file"
    else
        # Collect all merge entries
        local -a all_entries=()
        for optimized in debian alpine test; do
            if [ -f "_matrixlist_${optimized}.yml" ]; then
                # Read lines with { postgres: X, postgis: Y, variant: Z }
                while IFS= read -r line; do
                    if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\{.*\}[[:space:]]*$ ]]; then
                        all_entries+=("$line")
                    fi
                done < "_matrixlist_${optimized}.yml"
            fi
        done

        # Deduplicate using readarray to preserve lines
        local -a unique_entries=()
        readarray -t unique_entries < <(printf '%s\n' "${all_entries[@]}" | sort -u)

        # Expand every entry with every platform
        for entry in "${unique_entries[@]}"; do
            # Parse postgres, postgis, variant values using bash string manipulation
            # Entry format: "  - { postgres: 17, postgis: '3.6', variant: alpine }"

            # Remove leading whitespace and "- {"
            local cleaned="${entry#*\{}"
            cleaned="${cleaned%\}*}"

            # Extract values using parameter expansion
            local postgres_part="${cleaned#*postgres: }"
            local postgres="${postgres_part%%,*}"
            postgres="${postgres//\'/}"  # remove quotes
            postgres="${postgres// /}"  # remove spaces

            local postgis_part="${cleaned#*postgis: }"
            postgis_part="${postgis_part%%,*}"
            local postgis="${postgis_part//\'/}"  # remove quotes
            postgis="${postgis// /}"  # remove spaces

            local variant_part="${cleaned#*variant: }"
            variant_part="${variant_part%%,*}"
            variant_part="${variant_part%%\}*}"
            local variant="${variant_part//\'/}"  # remove quotes
            variant="${variant// /}"  # remove spaces

            # One entry per platform
            for platform in "${MATRIX_RUNNER_PLATFORMS[@]}"; do
                printf "  - { postgres: '%s', postgis: '%s', variant: '%s', runner-platform: '%s' }\n" \
                       "$postgres" "$postgis" "$variant" "$platform" >> "$temp_file"
            done
        done
    fi

    # --- Footer with summary statistics ---
    echo "" >> "$temp_file"
    echo "# ==============================================================================" >> "$temp_file"

    # Count entries in merge_include and build_include
    local merge_count=$(grep -c "^  - { postgres:" "$temp_file" || echo "0")
    local build_count=0

    # Count build_include entries (those with runner-platform)
    if grep -q "runner-platform:" "$temp_file" 2>/dev/null; then
        build_count=$(grep -c "runner-platform:" "$temp_file" || echo "0")
    fi

    # Calculate merge_include count (total - build_count)
    merge_count=$((merge_count - build_count))

    echo "# Summary: ${merge_count} combinations × ${#MATRIX_RUNNER_PLATFORMS[@]} platforms = ${build_count} build tasks" >> "$temp_file"
    echo "# Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$temp_file"
    echo "# ==============================================================================" >> "$temp_file"
    echo "# End of matrix.yml" >> "$temp_file"

    # Only overwrite if changed
    if [ -f "$output_file" ] && cmp -s "$temp_file" "$output_file"; then
        echo "matrix.yml unchanged"
        rm "$temp_file"
    else
        mv "$temp_file" "$output_file"
        echo "matrix.yml generated/updated"
    fi
}

echo " "
echo "=============================="
echo " - Generating matrix.yml from _matrixlist_*.yml files"
generate_matrix_yml "$MATRIX_FILE"

echo " "
echo "=============================="
echo " - update done && git status: "

git status
